###可重用代码的基本特性

1. 代码容易找到并且容易理解
2. 对代码的正确性很有把握
3. 不需要从包含它的外层代码分开
4. 当把代码用于新的程序里时，不需要对代码进行修改

###类的设计

####抽象性

>将类的抽象从它的实现分开

1. 忽略不重要的细节，使类的设计更简单，所有人对类的解释更趋于一致
2. 使类的实现更加灵活

####正规函数

>如果在所有设计良好的类中，某个函数的语义是相同的话，我们就称这个函数为正规函数

1. 拷贝构造函数
2. 析构函数
3. 基本的赋值运算符
4. 相等运算符和不等运算符

####Nice类

>类会提供某些特定函数，这些函数要么是在类的代码中被显式声明为公共的或保护的，要么是由编译器在程序中需要这些代码时隐式生成的

如果一个类提供了下列所有函数，我们就称这个类为Nice类：
1. 缺省构造函数
2. 拷贝构造函数
3. 赋值运算符
4. 相等运算符
5. 析构函数

####存在最小标准接口吗？

>对任何建议的某个最小标准接口函数，肯定会描述出某个类，他根本不需要这个函数

不存在

####浅拷贝和深拷贝

>x对象的浅拷贝是指：另一个和x相同类型的对象，并且它的数据成员和x相对应的数据成员具有相同的值的对象。x对象的深拷贝是指：另一个和x相同类型的对象，它具有x直接或间接指向的对象的一份拷贝，并且在拷贝里，所有共享和循环的联系依旧保留。

类一般不应该提供浅拷贝和深拷贝操作，因为这种操作可能会破坏类的某个不变性定义。

####接口一致性

>尽可能保持接口类的一致性

1. 具有接口一致性的类易于学习和记忆
2. 使用户更加容易地改变程序中对象的类型

####转型

#####隐式转型

>在类中定义一个只含有一个参数的构造函数或者显式定义一个转型操作方法

```
class To
{
public:
    To(const From&);
    ...
}

class From
{
public:
    operator To() const;
    ...
}
```

如果两种转型同时存在，会产生二义性。

>如果隐式转型表述一个自然映射或者用户默许的转型，就称之为敏感的

对于非敏感的转型，由于C++不支持多于一次的隐式转型，那么可以定义一个中间类防止隐式转型的发生

```
class Pool
{
public:
    class Size
    {
    public:
        Size(size_t n);
        ...
    }
    pool(Size n);
    ...
}
```
假设类可以转型为两种类型，则使用时需要用户使用强制转型区分。

####const关键字

>程序库设计者应该使用抽象const

































